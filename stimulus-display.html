<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stimulus Display - All Staircase Configurations</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        
        .stimulus-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            max-width: 1600px;
            margin: 0 auto;
        }
        
        .stimulus-container {
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .stimulus-header {
            text-align: center;
            margin-bottom: 10px;
        }
        
        .stimulus-title {
            font-weight: bold;
            font-size: 16px;
            color: #2c3e50;
            margin-bottom: 5px;
        }
        
        .stimulus-params {
            font-size: 12px;
            color: #7f8c8d;
        }
        
        .stimulus-svg {
            width: 100%;
            height: 300px;
            background-color: #ccc;
            border-radius: 4px;
        }
        
        .section-header {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            margin-bottom: 10px;
        }
        
        .section-header h2 {
            margin: 0;
            font-size: 24px;
        }
        
        .section-header p {
            margin: 5px 0 0 0;
            opacity: 0.9;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <h1>All Stimuli with Staircase Difficulty Levels</h1>
    
    <div class="stimulus-grid" id="stimulusGrid">
        <!-- Content will be generated by JavaScript -->
    </div>

    <script>
        // Staircase configuration from main.js - using tilt degree for Motion and Orientation only
        const STAIRCASE_CONFIG = {
            Motion: {
                parameter: 'directionRange',
                levels: [0, 25.71, 51.43, 77.14, 102.86, 128.57, 154.29, 180], // degrees - higher = more difficult (0° to 180° range from vertical)
                startLevel: 0,
                fixedParams: { motionSpeedDegreePerSecond: 5 }
            },
            Orientation: {
                parameter: 'tiltDegree', 
                levels: [0, 6.43, 12.86, 19.29, 25.71, 32.14, 38.57, 45], // degrees - higher = more difficult (0° to 45°)
                startLevel: 0,
                fixedParams: { stripeSpacingDegree: 0.05 }
            },
            Centrality: {
                parameter: 'centerPercentage',
                levels: [10, 17.14, 24.29, 31.43, 38.57, 42.86, 46.43, 50], // percent - higher = more difficult (10% to 50%)
                startLevel: 0
            },
            Bar: {
                parameter: 'heightRatio',
                levels: [
                    [1, 3], 
                    [1.14, 2.86], 
                    [1.29, 2.71], 
                    [1.43, 2.57], 
                    [1.57, 2.43], 
                    [1.71, 2.29], 
                    [1.86, 2.14], 
                    [2, 2]
                ], // ratios - closer ratios = more difficult (lower: 1→2, higher: 3→2)
                startLevel: 0
            }
        };

        // Helper function for deg2Pixel conversion (simplified version)
        function deg2Pixel(angleDeg, fallbackParams = {}) {
            const viewingDistanceCm = fallbackParams.viewingDistanceCm || 80;
            const screenSizeCm = fallbackParams.screenSizeCm || [71, 51];
            const resolution = fallbackParams.resolution || [3840, 2160];
            
            const physicalOffsetCm = viewingDistanceCm * Math.tan(angleDeg * Math.PI / 180);
            const pixelsPerCmX = resolution[0] / screenSizeCm[0];
            const pixelsPerCmY = resolution[1] / screenSizeCm[1];
            const pixelsPerCm = (pixelsPerCmX + pixelsPerCmY) / 2;
            
            return physicalOffsetCm * pixelsPerCm;
        }

        // Crosshair drawing function
        function drawCrosshair(svg, width, height, crosshairLen = 30, crosshairStrokeWidth = 2, color = 'black') {
            svg.selectAll('.crosshair').remove();
            const centerX = width / 2;
            const centerY = height / 2;
            
            // Horizontal line
            svg.append('line')
                .attr('class', 'crosshair')
                .attr('x1', centerX - crosshairLen / 2)
                .attr('y1', centerY)
                .attr('x2', centerX + crosshairLen / 2)
                .attr('y2', centerY)
                .attr('stroke', color)
                .attr('stroke-width', crosshairStrokeWidth);
            
            // Vertical line
            svg.append('line')
                .attr('class', 'crosshair')
                .attr('x1', centerX)
                .attr('y1', centerY - crosshairLen / 2)
                .attr('x2', centerX)
                .attr('y2', centerY + crosshairLen / 2)
                .attr('stroke', color)
                .attr('stroke-width', crosshairStrokeWidth);
        }

        // Motion stimulus function (continuous animation)
        function initMotionAnimation(containerId, motionSpeedDegreePerSecond = 10, directionRange = 0) {
            const svg = d3.select(`#${containerId}`);
            const width = 380;
            const height = 300;
            
            svg.attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`);
            
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = 60;
            const dotRadius = 3;
            const numDots = 30; // All dots are now signal dots
            
            let dots = [];
            let directions = [];
            
            // No rotation needed - dots will move within direction range from vertical
            const stimulusGroup = svg.append("g");
            
            // Draw circle boundary
            stimulusGroup.append("circle")
                .attr("cx", centerX)
                .attr("cy", centerY)
                .attr("r", radius)
                .attr("fill", "none")
                .attr("stroke", "white")
                .attr("stroke-width", "2");
            
            // Initialize dots
            for (let i = 0; i < numDots; i++) {
                let x, y;
                while (true) {
                    x = Math.random() * 2 * radius - radius;
                    y = Math.random() * 2 * radius - radius;
                    if (x * x + y * y <= radius * radius) break;
                }
                
                const dot = stimulusGroup.append("circle")
                    .attr("cx", centerX + x)
                    .attr("cy", centerY + y)
                    .attr("r", dotRadius)
                    .attr("fill", "white");
                
                dots.push({ elem: dot, x: x, y: y });
                
                // All dots are signal dots moving within direction range from vertical
                // Direction range: 0 means straight down, 90 means ±90° from vertical
                const angleFromVertical = (Math.random() * 2 - 1) * directionRange; // Random angle within ±directionRange
                const radians = (90 + angleFromVertical) * Math.PI / 180; // 90° is straight down in standard coordinates
                directions.push([Math.cos(radians), Math.sin(radians)]);
            }
            
            // Continuous animation
            function updateDots() {
                // Convert degrees/second to degrees/frame by dividing by frame rate (60fps)
                const motionSpeedDegreesPerFrame = motionSpeedDegreePerSecond / 60;
                const motionSpeedPixels = deg2Pixel(motionSpeedDegreesPerFrame);
                for (let i = 0; i < numDots; i++) {
                    let d = dots[i];
                    d.x += directions[i][0] * motionSpeedPixels;
                    d.y += directions[i][1] * motionSpeedPixels;
                    
                    // Wrap around if outside circle
                    if (d.x * d.x + d.y * d.y > radius * radius) {
                        while (true) {
                            let x = Math.random() * 2 * radius - radius;
                            let y = Math.random() * 2 * radius - radius;
                            if (x * x + y * y <= radius * radius) {
                                d.x = x;
                                d.y = y;
                                break;
                            }
                        }
                        // Re-randomize dot direction within range (all dots are signal dots)
                        const angleFromVertical = (Math.random() * 2 - 1) * directionRange;
                        const radians = (90 + angleFromVertical) * Math.PI / 180;
                        directions[i] = [Math.cos(radians), Math.sin(radians)];
                    }
                    
                    d.elem
                        .attr("cx", centerX + d.x)
                        .attr("cy", centerY + d.y);
                }
            }
            
            drawCrosshair(svg, width, height);
            setInterval(updateDots, 1000 / 60); // 60 fps continuous
        }

        // Grating stimulus function
        function initGratingStimulus(containerId, orientation = "vertical", spacingDegree = 0.05, tiltDegree = 0) {
            const svg = d3.select(`#${containerId}`);
            const width = 380;
            const height = 300;
            
            svg.attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`);
            
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = 60;
            const stripeWidth = 3;
            
            // Create a group for the rotated stimulus
            const stimulusGroup = svg.append("g")
                .attr("transform", `rotate(${tiltDegree}, ${centerX}, ${centerY})`);
            
            // Define circular clip mask (in the rotated group)
            stimulusGroup.append("clipPath")
                .attr("id", `clip-${containerId}`)
                .append("circle")
                .attr("cx", centerX)
                .attr("cy", centerY)
                .attr("r", radius);
            
            // Group for stripes (clipped and rotated)
            const g = stimulusGroup.append("g")
                .attr("clip-path", `url(#clip-${containerId})`);
            
            const spacingPixels = deg2Pixel(spacingDegree);
            const totalWidth = stripeWidth + spacingPixels;
            
            if (orientation === "vertical") {
                const numStripes = Math.ceil(width / totalWidth);
                for (let i = -numStripes; i < numStripes * 2; i++) {
                    g.append("rect")
                        .attr("x", i * totalWidth)
                        .attr("y", 0)
                        .attr("width", stripeWidth)
                        .attr("height", height)
                        .attr("fill", "#fff");
                }
            } else {
                const numStripes = Math.ceil(height / totalWidth);
                for (let i = -numStripes; i < numStripes * 2; i++) {
                    g.append("rect")
                        .attr("x", 0)
                        .attr("y", i * totalWidth)
                        .attr("width", width)
                        .attr("height", stripeWidth)
                        .attr("fill", "#fff");
                }
            }
            
            // Circle outline (in the rotated group)
            stimulusGroup.append("circle")
                .attr("cx", centerX)
                .attr("cy", centerY)
                .attr("r", radius)
                .attr("fill", "none")
                .attr("stroke", "white")
                .attr("stroke-width", "2");
            
            drawCrosshair(svg, width, height);
        }

        // Grid stimulus function
        function initGridStimulus(containerId, centerColor = 'black', centerPercentage = 25) {
            const svg = d3.select(`#${containerId}`);
            const width = 380;
            const height = 300;
            
            svg.attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`);
            
            const centerX = width / 2;
            const centerY = height / 2;
            const gridSize = 10;
            const cellSize = 10;
            
            // Calculate radius based on center percentage
            let radius = Math.sqrt(centerPercentage / 100 * (gridSize * gridSize) / Math.PI);
            const noiseLevel = 0.45;
            
            // Calculate grid starting position
            const gridStartX = centerX - (gridSize * cellSize) / 2;
            const gridStartY = centerY - (gridSize * cellSize) / 2;
            
            const center = { x: 4.5, y: 4.5 };
            let grid = [];
            
            // Create grid pattern
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    const dx = x - center.x;
                    const dy = y - center.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    let filled = dist < radius;
                    grid.push({ x, y, filled });
                }
            }
            
            // Add edge noise
            grid.forEach(cell => {
                const neighbors = [[0,1], [1,0], [0,-1], [-1,0]];
                const isEdge = cell.filled && neighbors.some(([dx, dy]) => {
                    const nx = cell.x + dx;
                    const ny = cell.y + dy;
                    if (nx < 0 || ny < 0 || nx >= gridSize || ny >= gridSize) return true;
                    const neighbor = grid[ny * gridSize + nx];
                    return !neighbor.filled;
                });
                
                if (isEdge && Math.random() < noiseLevel) {
                    cell.filled = !cell.filled;
                }
            });
            
            // Invert if center should be white
            if (centerColor === 'white') {
                grid.forEach(cell => cell.filled = !cell.filled);
            }
            
            // Draw grid
            svg.selectAll("rect")
                .data(grid)
                .enter()
                .append("rect")
                .attr("x", d => gridStartX + d.x * cellSize)
                .attr("y", d => gridStartY + d.y * cellSize)
                .attr("width", cellSize)
                .attr("height", cellSize)
                .attr("fill", d => d.filled ? "black" : "white")
                .attr("stroke", "#999")
                .attr("stroke-width", "0.5");
            
            drawCrosshair(svg, width, height);
        }

        // Bar chart stimulus function
        function initBarChartStimulus(containerId, heights = [1, 1]) {
            const svg = d3.select(`#${containerId}`);
            const width = 380;
            const height = 300;
            
            svg.attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`);
            
            const barWidth = 30;
            const barMaxHeight = 80;
            const spacing = 60;
            
            // Calculate bar positions
            const leftBarX = width / 2 - spacing - barWidth / 2;
            const rightBarX = width / 2 + spacing - barWidth / 2;
            const baseY = height / 2 + 40;
            
            // Draw left bar
            const leftHeight = (heights[0] / 3) * barMaxHeight; // Normalize to max height
            svg.append("rect")
                .attr("x", leftBarX)
                .attr("y", baseY - leftHeight)
                .attr("width", barWidth)
                .attr("height", leftHeight)
                .attr("fill", "black");
            
            // Draw right bar  
            const rightHeight = (heights[1] / 3) * barMaxHeight; // Normalize to max height
            svg.append("rect")
                .attr("x", rightBarX)
                .attr("y", baseY - rightHeight)
                .attr("width", barWidth)
                .attr("height", rightHeight)
                .attr("fill", "black");
            
            drawCrosshair(svg, width, height);
        }

        // Generate the display grid
        function generateStimulusGrid() {
            const grid = document.getElementById('stimulusGrid');
            grid.innerHTML = '';
            
            // Motion stimuli
            const motionHeader = document.createElement('div');
            motionHeader.className = 'section-header';
            motionHeader.innerHTML = `
                <h2>Motion Detection</h2>
                <p>Signal dots moving downward within varying direction ranges</p>
                <p><strong>Fixed Parameters:</strong> Motion Speed: ${STAIRCASE_CONFIG.Motion.fixedParams.motionSpeedDegreePerSecond}°/second</p>
            `;
            grid.appendChild(motionHeader);
            
            STAIRCASE_CONFIG.Motion.levels.forEach((directionRange, i) => {
                const container = document.createElement('div');
                container.className = 'stimulus-container';
                container.innerHTML = `
                    <div class="stimulus-header">
                        <div class="stimulus-title">Motion - Level ${i + 1}</div>
                        <div class="stimulus-params">Direction Range: ±${directionRange}°</div>
                    </div>
                    <svg id="motion-${i}" class="stimulus-svg"></svg>
                `;
                grid.appendChild(container);
            });
            
            // Orientation stimuli
            const orientationHeader = document.createElement('div');
            orientationHeader.className = 'section-header';
            orientationHeader.innerHTML = `
                <h2>Orientation Discrimination</h2>
                <p>Vertical and horizontal gratings with varying tilt degree</p>
                <p><strong>Fixed Parameters:</strong> Stripe Spacing: ${STAIRCASE_CONFIG.Orientation.fixedParams.stripeSpacingDegree}°</p>
            `;
            grid.appendChild(orientationHeader);
            
            STAIRCASE_CONFIG.Orientation.levels.forEach((tiltDegree, i) => {
                const container = document.createElement('div');
                container.className = 'stimulus-container';
                container.innerHTML = `
                    <div class="stimulus-header">
                        <div class="stimulus-title">Orientation - Level ${i + 1}</div>
                        <div class="stimulus-params">Tilt: ${tiltDegree}°</div>
                    </div>
                    <svg id="orientation-${i}" class="stimulus-svg"></svg>
                `;
                grid.appendChild(container);
            });
            
            // Centrality stimuli
            const centralityHeader = document.createElement('div');
            centralityHeader.className = 'section-header';
            centralityHeader.innerHTML = `
                <h2>Centrality Judgment</h2>
                <p>Grid patterns with varying center area percentages</p>
            `;
            grid.appendChild(centralityHeader);
            
            STAIRCASE_CONFIG.Centrality.levels.forEach((percentage, i) => {
                const container = document.createElement('div');
                container.className = 'stimulus-container';
                container.innerHTML = `
                    <div class="stimulus-header">
                        <div class="stimulus-title">Centrality - Level ${i + 1}</div>
                        <div class="stimulus-params">Center: ${percentage}%</div>
                    </div>
                    <svg id="centrality-${i}" class="stimulus-svg"></svg>
                `;
                grid.appendChild(container);
            });
            
            // Bar stimuli
            const barHeader = document.createElement('div');
            barHeader.className = 'section-header';
            barHeader.innerHTML = `
                <h2>Height Comparison</h2>
                <p>Bar pairs with varying height ratios</p>
            `;
            grid.appendChild(barHeader);
            
            STAIRCASE_CONFIG.Bar.levels.forEach((ratio, i) => {
                const container = document.createElement('div');
                container.className = 'stimulus-container';
                container.innerHTML = `
                    <div class="stimulus-header">
                        <div class="stimulus-title">Bar - Level ${i + 1}</div>
                        <div class="stimulus-params">Ratio: [${ratio[0]}:${ratio[1]}]</div>
                    </div>
                    <svg id="bar-${i}" class="stimulus-svg"></svg>
                `;
                grid.appendChild(container);
            });
        }

        // Initialize all stimuli
        function initializeAllStimuli() {
            // Initialize Motion animations
            STAIRCASE_CONFIG.Motion.levels.forEach((directionRange, i) => {
                initMotionAnimation(`motion-${i}`, STAIRCASE_CONFIG.Motion.fixedParams.motionSpeedDegreePerSecond, directionRange);
            });
            
            // Initialize Orientation gratings - all vertical for consistency
            STAIRCASE_CONFIG.Orientation.levels.forEach((tiltDegree, i) => {
                initGratingStimulus(`orientation-${i}`, "vertical", STAIRCASE_CONFIG.Orientation.fixedParams.stripeSpacingDegree, tiltDegree);
            });
            
            // Initialize Centrality grids - all with black center for consistency
            STAIRCASE_CONFIG.Centrality.levels.forEach((percentage, i) => {
                initGridStimulus(`centrality-${i}`, 'black', percentage);
            });
            
            // Initialize Bar charts
            STAIRCASE_CONFIG.Bar.levels.forEach((ratio, i) => {
                initBarChartStimulus(`bar-${i}`, ratio);
            });
        }

        // Run on page load
        window.addEventListener('DOMContentLoaded', () => {
            generateStimulusGrid();
            setTimeout(initializeAllStimuli, 100); // Small delay to ensure DOM is ready
        });
    </script>
</body>
</html>